using System.Reflection;
using UnityEngine;
using UnityEngine.Rendering.Universal;
using System;
using System.Collections.Generic;


#if UNITY_EDITOR
using UnityEditor;
#endif


namespace SanctumCorp
{
	public class DynamicShadowCaster2DMaker : MonoBehaviour
	{
#if UNITY_EDITOR
		[SerializeField] private Sprite[] sprites;
		[SerializeField] private DefaultAsset folder;
		[SerializeField] private string targetFolderName;

		private List<GameObject> madeGameObjects;

		public void GenerateShadows()
		{
			EditorApplication.delayCall += () =>
			{
				foreach (var sprite in sprites)
				{
					var gameObj = InstantiateGo(sprite);
					DoShasow(sprite, gameObj);
					RefreshShadowCaster(gameObj);
				}
			};
		}



		public void DoShasow(Sprite sprite, GameObject gameObj)
		{
			var caster = gameObj.GetComponent<ShadowCaster2D>();
			if (caster == null)
			{
				caster = gameObj.AddComponent<ShadowCaster2D>();
			}

			FieldInfo shapePathField = typeof(ShadowCaster2D).GetField("m_ShapePath", BindingFlags.NonPublic | BindingFlags.Instance);

			Vector3[] dinamicShape = MakePoints.GetPoints(sprite, transform);

			if (shapePathField != null)
			{
				shapePathField.SetValue(caster, dinamicShape);
			}
		}

		public void RefreshShadowCaster(GameObject gameObj)
		{
			var caster = gameObj.GetComponent<ShadowCaster2D>();
			if (caster == null)
			{
				Debug.LogWarning("ShadowCaster2D component not found on this GameObject.");
				return;
			}

			FieldInfo shapePathField = typeof(ShadowCaster2D).GetField("m_ShapePath", BindingFlags.NonPublic | BindingFlags.Instance);
			FieldInfo meshField = typeof(ShadowCaster2D).GetField("m_Mesh", BindingFlags.NonPublic | BindingFlags.Instance);

			Assembly universalRPAssembly = typeof(ShadowCaster2D).Assembly;

			Type shadowUtilityType = universalRPAssembly.GetType("UnityEngine.Rendering.Universal.ShadowUtility");

			MethodInfo generateShadowMeshMethod = null;
			if (shadowUtilityType != null)
			{
				generateShadowMeshMethod = shadowUtilityType.GetMethod("GenerateShadowMesh", BindingFlags.Public | BindingFlags.Static);
			}


			if (shapePathField == null || meshField == null || generateShadowMeshMethod == null)
			{
				Debug.LogError($"Failed to get ShadowCaster2D's internal fields or ShadowUtility.GenerateShadowMesh method via reflection. " +
							   $"ShapePath: {shapePathField != null}, Mesh: {meshField != null}, ShadowUtilityType: {shadowUtilityType != null}, GenerateShadowMesh: {generateShadowMeshMethod != null}");
				return;
			}

			meshField.SetValue(caster, new Mesh());

			Vector3[] currentShapePath = (Vector3[])shapePathField.GetValue(caster);

			generateShadowMeshMethod.Invoke(null, new object[] { meshField.GetValue(caster), currentShapePath });

			Debug.Log("ShadowCaster2D refreshed (mesh regenerated by ShadowUtility).");
		}


		[ContextMenu("Save to folder")]
		public void SaveAsGameObject()
		{
			string baseFolderPath = AssetDatabase.GetAssetPath(folder);
			if (AssetDatabase.IsValidFolder(baseFolderPath))
			{
				Debug.Log("Destination folder is valid");

				if (targetFolderName == "" || targetFolderName == " ") // Protect from empty string or space-misclick
				{
					Debug.LogError("Target folder name wasn't filled");
					return;
				}
				SaveToFolder.Save(baseFolderPath, targetFolderName, madeGameObjects);
			}
			else
			{
				Debug.LogError("Folder is invalid");
			}
		}

		private GameObject InstantiateGo(UnityEngine.Object obj)
		{
			string goName = "Shadow_" + obj.name;

			GameObject go = new GameObject(goName);
			Undo.RegisterCreatedObjectUndo(go, $"created {goName}");
			Debug.Log("transform " + (transform != null));
			Debug.Log("gameobj " + (go != null));
			Undo.SetTransformParent(go.transform, transform, "Reparent");

			Undo.RecordObject(go, "Clear position");
			go.transform.localPosition = Vector3.zero;

			EditorUtility.SetDirty(go.transform);

			madeGameObjects.Add(go);

			return go;
		}

		[ContextMenu("Clear shadows")]
		private void CLearMadeGameobjects()
		{
			foreach (GameObject go in madeGameObjects)
				if (go != null)
					Undo.DestroyObjectImmediate(go);
			madeGameObjects.Clear();
		}
#endif
	}
}
